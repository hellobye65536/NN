package hb.tensor;

import java.util.Arrays;
import java.util.function.DoubleSupplier;
import java.util.stream.IntStream;

/**
 * ConcreteTensor represents a Tensor with actual values.
 */
public final class ConcreteTensor implements Tensor {
    private final float[] buffer;
    /**
     * Stores the shape of the tensor
     */
    private final int[] shape;
    /**
     * Used to index into the flat buffer.
     * Check <code>calculateIndex()</code> for details.
     */
    private final int[] strides;
    /**
     * Used to index into the flat buffer.
     * Check <code>calculateIndex()</code> for details.
     */
    private final int offset;

    private ConcreteTensor(float[] buffer, int[] shape, int[] strides, int offset) {
        this.buffer = buffer;
        this.shape = shape;
        this.strides = strides;
        this.offset = offset;
    }

    /**
     * Checks if a given shape is valid
     *
     * @param shape  The given shape
     * @param length A target length, or -1 if none
     */
    private static void checkShape(int[] shape, int length) {
        for (int s : shape) {
            if (s <= 0)
                throw new IllegalArgumentException();
        }

        if (length != -1) {
            if (length != Arrays.stream(shape).reduce(1, (a, b) -> a * b))
                throw new IllegalArgumentException();
        }
    }

    /**
     * Constructs a ConcreteTensor from a given row-major array and shape. Does not copy the array.
     *
     * @param data  The row-major array representing the tensor data
     * @param shape The shape of the tensor
     * @return A new ConcreteTensor object
     * @throws IllegalArgumentException If the shape is invalid or does not match the data length
     */
    public static ConcreteTensor fromRowMajor(float[] data, int[] shape) {
        checkShape(shape, data.length);

        int[] strides = new int[shape.length];

        int sublength = data.length;
        for (int i = 0; i < shape.length; i++) {
            sublength /= shape[i];
            strides[i] = sublength;
        }

        return new ConcreteTensor(data, shape, strides, 0);
    }

    /**
     * Constructs a ConcreteTensor from a given column-major array and shape. Does not copy the array.
     *
     * @param data  The row-major array representing the tensor data
     * @param shape The shape of the tensor
     * @return A new ConcreteTensor object
     * @throws IllegalArgumentException If the shape is invalid or does not match the data length
     */
    public static ConcreteTensor fromColumnMajor(float[] data, int[] shape) {
        checkShape(shape, data.length);

        int[] strides = new int[shape.length];

        int sublength = data.length;
        for (int i = shape.length - 1; i >= 0; i--) {
            sublength /= shape[i];
            strides[i] = sublength;
        }

        return new ConcreteTensor(data, shape, strides, 0);
    }

    /**
     * Creates a ConcreteTensor filled with values generated by the provided DoubleSupplier function.
     *
     * @param shape The shape of the tensor
     * @param func  The DoubleSupplier function that generates values for filling the tensor
     * @return A new ConcreteTensor object filled with the generated values
     * @throws IllegalArgumentException If the shape is invalid
     */
    public static ConcreteTensor fill(int[] shape, DoubleSupplier func) {
        checkShape(shape, -1);

        int[] strides = new int[shape.length];
        int cur_stride = 1;
        for (int i = shape.length - 1; i >= 0; i--) {
            strides[i] = cur_stride;
            cur_stride *= shape[i];
        }

        float[] data = new float[cur_stride];
        for (int i = 0; i < data.length; i++) {
            data[i] = (float) func.getAsDouble();
        }

        return new ConcreteTensor(data, shape, strides, 0);
    }

    /**
     * Returns the rank (number of dimensions) of the tensor.
     *
     * @return The rank of the tensor
     */
    public int rank() {
        return shape.length;
    }

    /**
     * Returns the shape of the tensor.
     *
     * @return An array representing the shape of the tensor
     */
    public int[] shape() {
        return shape;
    }

    /**
     * Returns the position in the array for a given index based on the stride.
     */
    private int calculateIndex(int[] index) {
        return IntStream.range(0, shape.length).map(i -> index[i] * strides[i]).sum() + offset;
    }

    /**
     * Check if the given index is valid.
     */
    private void checkIndex(int[] index) {
        if (index.length != shape.length)
            throw new IndexOutOfBoundsException("Incorrect dimensions");
        for (int i = 0; i < index.length; i++) {
            if (index[i] >= shape[i])
                throw new IndexOutOfBoundsException("Index out of bounds");
        }
    }

    /**
     * Retrieves the value at the specified index in the tensor.
     *
     * @param index The index representing the position of the desired value
     * @return The value at the specified index in the tensor
     * @throws IndexOutOfBoundsException If the index is out of bounds or has incorrect dimensions
     */
    public float get(int... index) {
        checkIndex(index);
        return buffer[calculateIndex(index)];
    }

    /**
     * Sets the value at the specified index in the tensor.
     *
     * @param value The value to be set
     * @param index The index representing the position where the value should be set
     * @throws IndexOutOfBoundsException If the index is out of bounds or has incorrect dimensions
     */
    public void set(float value, int... index) {
        checkIndex(index);
        buffer[calculateIndex(index)] = value;
    }

    @Override
    public Tensor add(Tensor lhs_g) {
        if (!(lhs_g instanceof ConcreteTensor lhs))
            return lhs_g.add(this);



        return null;
    }
}
